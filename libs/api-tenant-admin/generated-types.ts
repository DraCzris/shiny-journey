/**
 * Generated by orval v6.29.1 üç∫
 * Do not edit manually.
 * Tenant API
 * API used for tenant application
 * OpenAPI spec version: 1
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import axios from 'axios'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
export type SetPlan200 = Subscription | null

export type AccountTypePayload = {
  type: AccountType
}

export type UnmetRequirementsListType =
  (typeof UnmetRequirementsListType)[keyof typeof UnmetRequirementsListType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UnmetRequirementsListType = {
  unmet_requirements_list: 'unmet_requirements_list',
} as const

export type UnmetRequirementsList = {
  data: CompletenessRequirementResult[]
  type?: UnmetRequirementsListType
}

export type ResolutionSymptomAnyOf = { [key: string]: any }

export type ResolutionSymptom = ResolutionSymptomAnyOf | null

export type ResolutionFeatureAnyOf = { [key: string]: any }

export type ResolutionFeature = ResolutionFeatureAnyOf | null

export type Resolution = {
  classification: Classification
  feature?: ResolutionFeature
  id: string
  resolved_by: string
  symptom?: ResolutionSymptom
}

export type RerouteEventDataType =
  (typeof RerouteEventDataType)[keyof typeof RerouteEventDataType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RerouteEventDataType = {
  reroute_report: 'reroute_report',
} as const

export type RerouteEventData = {
  assignee_from: string
  assignee_to: string
  type?: RerouteEventDataType
}

export type ReportResolutionMatch = {
  confidence: number
  resolution: Resolution
}

export type ReportCounts = {
  incomplete?: number
  link_related?: number
  merge?: number
  not_a_bug?: number
  reoccurring_report?: number
  reroute?: number
  total?: number
}

export type ReportBehaviourMatch = {
  behaviour: Behaviour
  confidence: number
}

export type ReportAnalysisResultSymptomMatchingLog = MatchingLog | null

export type ReportAnalysisResultSymptom = AnalyzedBehaviour | null

export type ReportAnalysisResultIsComplete = boolean | null

export type ReportAnalysisResultInvestigation = Investigation | null

export type ReportAnalysisResultFeatureMatchingLog = MatchingLog | null

export type ReportAnalysisResultFeature = AnalyzedBehaviour | null

export type ReportAnalysisResultExtractedSymptom = BehaviourWithType | null

export type ReportAnalysisResultExtractedFeature = BehaviourWithType | null

export type ReportAnalysisResult = {
  extracted_feature?: ReportAnalysisResultExtractedFeature
  extracted_symptom?: ReportAnalysisResultExtractedSymptom
  feature?: ReportAnalysisResultFeature
  feature_matching_log?: ReportAnalysisResultFeatureMatchingLog
  investigation?: ReportAnalysisResultInvestigation
  is_complete?: ReportAnalysisResultIsComplete
  resolution_matches?: ReportResolutionMatch[]
  symptom?: ReportAnalysisResultSymptom
  symptom_matching_log?: ReportAnalysisResultSymptomMatchingLog
  tenant_id: string
}

export type Nature = (typeof Nature)[keyof typeof Nature]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Nature = {
  known: 'known',
  unknown: 'unknown',
  invalid: 'invalid',
} as const

export type MergeSuggestionType =
  (typeof MergeSuggestionType)[keyof typeof MergeSuggestionType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MergeSuggestionType = {
  merge_suggestion: 'merge_suggestion',
} as const

export type MergeSuggestion = {
  merge_source: JiraOpen
  merge_target: JiraOpen
  merged_title: string
  type?: MergeSuggestionType
}

export type MatchingSubIterations = {
  id: string
  output: string
}

export type MatchingIteration = {
  action: string
  current_matches_result?: BehaviourContentMatch[]
  cursor: Behaviour
  id: string
  searched_behaviour: Behaviour
  sub_iteration?: MatchingSubIterations[]
}

export type MatchingLog = {
  iterations?: MatchingIteration[]
  result?: BehaviourContentMatch[]
}

export type JiraOpenType = (typeof JiraOpenType)[keyof typeof JiraOpenType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JiraOpenType = {
  jira_open: 'jira_open',
} as const

export type JiraOpen = {
  assignee?: string
  created_at: string
  description: string
  id: string
  link: string
  public_id: string
  title: string
  type?: JiraOpenType
}

export type JiraClosedType =
  (typeof JiraClosedType)[keyof typeof JiraClosedType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JiraClosedType = {
  jira_closed: 'jira_closed',
} as const

export type JiraClosed = {
  assignee?: string
  closed_at: string
  created_at: string
  description: string
  id: string
  link: string
  public_id: string
  solver: string
  title: string
  type?: JiraClosedType
}

export type InvestigationSymptomAnyOf = { [key: string]: any }

export type InvestigationSymptom = InvestigationSymptomAnyOf | null

export type Investigation = {
  classification: Classification
  feature?: InvestigationFeature
  id: string
  symptom?: InvestigationSymptom
}

export type InvestigationFeatureAnyOf = { [key: string]: any }

export type InvestigationFeature = InvestigationFeatureAnyOf | null

export type Intervention = {
  event: Event
  id: string
}

export type HtmlContentType =
  (typeof HtmlContentType)[keyof typeof HtmlContentType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HtmlContentType = {
  html: 'html',
} as const

export type HtmlContent = {
  content: string
  type?: HtmlContentType
}

export type EventType = (typeof EventType)[keyof typeof EventType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EventType = {
  not_a_bug: 'not_a_bug',
  incomplete: 'incomplete',
  reoccurring_report: 'reoccurring_report',
  link_related: 'link_related',
  reroute: 'reroute',
  merge: 'merge',
} as const

export type EventSummaryItem =
  | HtmlContent
  | BugReportList
  | UnmetRequirementsList
  | MergeSuggestion

export type EventRerouteData = RerouteEventData | null

export type Event = {
  confidence?: number
  report: JiraOpen
  reroute_data?: EventRerouteData
  result: ReportAnalysisResult
  summary: EventSummaryItem[]
  type: EventType
}

export type CompletenessRequirementResultQuestion = string | null

export type CompletenessRequirement = {
  definition: string
  id: string
}

export type CompletenessRequirementResult = {
  is_fulfilled: boolean
  question?: CompletenessRequirementResultQuestion
  requirement: CompletenessRequirement
  summary: string
}

export type Classification =
  (typeof Classification)[keyof typeof Classification]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Classification = {
  bug: 'bug',
  not_bug__feature_not_supported: 'not_bug__feature_not_supported',
  not_bug__invalid_symptom: 'not_bug__invalid_symptom',
} as const

export type BugReportListType =
  (typeof BugReportListType)[keyof typeof BugReportListType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BugReportListType = {
  bug_report_list: 'bug_report_list',
} as const

export type BugReportListDataItem = JiraClosed | JiraOpen

export type BugReportList = {
  data: BugReportListDataItem[]
  type?: BugReportListType
}

export type BehaviourWithTypeType =
  (typeof BehaviourWithTypeType)[keyof typeof BehaviourWithTypeType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BehaviourWithTypeType = {
  symptom: 'symptom',
  feature: 'feature',
} as const

export type BehaviourWithTypeContent = { [key: string]: any }

export type BehaviourWithType = {
  content: BehaviourWithTypeContent
  id?: string
  type: BehaviourWithTypeType
}

export type BehaviourContent = { [key: string]: any }

export type Behaviour = {
  content: BehaviourContent
  id?: string
}

export type BehaviourContentMatch = {
  behaviour: Behaviour
  confidence: number
  reasoning?: string
}

export type AnalyzedBehaviour = {
  confidence: number
  matched_features?: ReportBehaviourMatch[]
  matched_symptoms?: ReportBehaviourMatch[]
  nature: Nature
}

export type AnalysisReport = {
  counts: ReportCounts
  interventions?: Intervention[]
}

export type PendingType = (typeof PendingType)[keyof typeof PendingType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PendingType = {
  pending: 'pending',
} as const

export type Pending = {
  scheduled_at: string
  type?: PendingType
}

export type CompletedType = (typeof CompletedType)[keyof typeof CompletedType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CompletedType = {
  completed: 'completed',
} as const

export type Completed = {
  finished_at: string
  scheduled_at: string
  started_at: string
  type?: CompletedType
}

export type AnalysisReportStatusStatusAnyOf = Pending | Completed

/**
 * @nullable
 */
export type AnalysisReportStatusStatus =
  AnalysisReportStatusStatusAnyOf | null | null

export type AnalysisReportStatus = {
  /** @nullable */
  status: AnalysisReportStatusStatus
}

export type TimeFrameMetrics = {
  processed_average: number
  total_average: number
  unprocessed_average: number
}

export type MetricsCycleTimeLast7Days = TimeFrameMetrics | null

export type MetricsCycleTimeLast365Days = TimeFrameMetrics | null

export type MetricsCycleTimeLast30Days = TimeFrameMetrics | null

export type MetricsCycleTimeAllTime = TimeFrameMetrics | null

export type MetricsCycleTime = {
  all_time?: MetricsCycleTimeAllTime
  last_30_days?: MetricsCycleTimeLast30Days
  last_365_days?: MetricsCycleTimeLast365Days
  last_7_days?: MetricsCycleTimeLast7Days
}

export type AnalyzedIssueSummary = string | null

export type AnalyzedIssue = {
  id: string
  summary?: AnalyzedIssueSummary
  title: string
  url: string
}

export type IntegrationCustomAction = string | null

export type Integration = {
  configured: boolean
  custom_action?: IntegrationCustomAction
  enabled: boolean
}

export type SupportedIntegrations = {
  github: Integration
  jira: Integration
  jira_api: Integration
  slack: Integration
  zendesk: Integration
}

export type ProjectStatus = {
  enabled: boolean
  id: string
}

export type JiraAPIConfiguration = {
  base_url: string
  email: string
  token: string
}

export type JiraAPIConfigurationResponseConfiguration =
  JiraAPIConfiguration | null

export type JiraAPIConfigurationResponse = {
  configuration?: JiraAPIConfigurationResponseConfiguration
}

export type Project = {
  enabled: boolean
  external_id: string
  name: string
}

export type JiraInfo = {
  projects: Project[]
}

export type ZendeskInfoConfiguration = ZendeskConfiguration | null

export type ZendeskInfo = {
  configuration?: ZendeskInfoConfiguration
  field_for_jira_integration: ZendeskField
}

export type ZendeskFieldId = string | null

export type ZendeskField = {
  id?: ZendeskFieldId
  name: string
}

export type ZendeskConfiguration = {
  email: string
  subdomain: string
  token: string
}

export type SetPlanPayload = {
  plan_id: string
}

export type SetInitialPlanPayload = {
  cancel_url: string
  plan_id: string
  success_url: string
}

export type SetInitialPlanResponse = {
  payment_link: string
}

export type GetPlansResponse = {
  current_subscription: GetPlansResponseCurrentSubscription
  plans: Plan[]
}

export type AccountType = (typeof AccountType)[keyof typeof AccountType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountType = {
  showcase: 'showcase',
  standard: 'standard',
} as const

export type OnboardingStatusAccountType = AccountType | null

export type OnboardingStatus = {
  account_type?: OnboardingStatusAccountType
  has_accepted_terms: boolean
  has_subscription: boolean
}

export type TenantName = string | null

export type Tenant = {
  account: TenantAccount
  id: string
  name?: TenantName
}

export type Subscription = {
  active_from: string
  data: Plan
  schedule?: SubscriptionSchedule
}

export type GetPlansResponseCurrentSubscription = Subscription | null

export type StandardAccountType =
  (typeof StandardAccountType)[keyof typeof StandardAccountType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StandardAccountType = {
  standard: 'standard',
} as const

export type StandardAccountSubscription = Subscription | null

export type StandardAccount = {
  is_linked: boolean
  quota?: StandardAccountQuota
  subscription?: StandardAccountSubscription
  type?: StandardAccountType
}

export type ShowcaseAccountType =
  (typeof ShowcaseAccountType)[keyof typeof ShowcaseAccountType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ShowcaseAccountType = {
  showcase: 'showcase',
} as const

export type ShowcaseAccount = {
  type?: ShowcaseAccountType
}

export type TenantAccount = ShowcaseAccount | StandardAccount

export type ScheduleScheduledTo = string | null

export type Schedule = {
  new_plan: Plan
  scheduled_to?: ScheduleScheduledTo
}

export type SubscriptionSchedule = Schedule | null

export type Quota = {
  limit: number
  used: number
}

export type StandardAccountQuota = Quota | null

export type PlanPriceVat = number | string

export type PlanPrice = number | string

export type Plan = {
  billing_period: string
  id: string
  is_default: boolean
  price: PlanPrice
  price_vat: PlanPriceVat
  title: string
}

/**
 * @summary Get Tenant
 */
export const getTenant = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Tenant>> => {
  return axios.get(`/get-tenant/`, options)
}

export const getGetTenantQueryKey = () => {
  return [`/get-tenant/`] as const
}

export const getGetTenantQueryOptions = <
  TData = Awaited<ReturnType<typeof getTenant>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTenantQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenant>>> = ({
    signal,
  }) => getTenant({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTenant>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetTenantQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTenant>>
>
export type GetTenantQueryError = AxiosError<unknown>

/**
 * @summary Get Tenant
 */
export const useGetTenant = <
  TData = Awaited<ReturnType<typeof getTenant>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetTenantQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Onboarding Status
 */
export const onboardingStatus = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<OnboardingStatus>> => {
  return axios.get(`/onboarding-status/`, options)
}

export const getOnboardingStatusQueryKey = () => {
  return [`/onboarding-status/`] as const
}

export const getOnboardingStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof onboardingStatus>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof onboardingStatus>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getOnboardingStatusQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof onboardingStatus>>
  > = ({ signal }) => onboardingStatus({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof onboardingStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type OnboardingStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof onboardingStatus>>
>
export type OnboardingStatusQueryError = AxiosError<unknown>

/**
 * @summary Onboarding Status
 */
export const useOnboardingStatus = <
  TData = Awaited<ReturnType<typeof onboardingStatus>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof onboardingStatus>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getOnboardingStatusQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Plans
 */
export const getPlans = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GetPlansResponse>> => {
  return axios.get(`/get-plans/`, options)
}

export const getGetPlansQueryKey = () => {
  return [`/get-plans/`] as const
}

export const getGetPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPlansQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlans>>> = ({
    signal,
  }) => getPlans({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPlans>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPlans>>
>
export type GetPlansQueryError = AxiosError<unknown>

/**
 * @summary Get Plans
 */
export const useGetPlans = <
  TData = Awaited<ReturnType<typeof getPlans>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPlans>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetPlansQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Accept Terms
 */
export const acceptTerms = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/accept-terms/`, undefined, options)
}

export const getAcceptTermsMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acceptTerms>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof acceptTerms>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof acceptTerms>>,
    void
  > = () => {
    return acceptTerms(axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AcceptTermsMutationResult = NonNullable<
  Awaited<ReturnType<typeof acceptTerms>>
>

export type AcceptTermsMutationError = AxiosError<unknown>

/**
 * @summary Accept Terms
 */
export const useAcceptTerms = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acceptTerms>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof acceptTerms>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAcceptTermsMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Set Initial Plan
 */
export const setInitialPlan = (
  setInitialPlanPayload: SetInitialPlanPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<SetInitialPlanResponse>> => {
  return axios.post(`/set-initial-plan/`, setInitialPlanPayload, options)
}

export const getSetInitialPlanMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setInitialPlan>>,
    TError,
    { data: SetInitialPlanPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof setInitialPlan>>,
  TError,
  { data: SetInitialPlanPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setInitialPlan>>,
    { data: SetInitialPlanPayload }
  > = (props) => {
    const { data } = props ?? {}

    return setInitialPlan(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetInitialPlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof setInitialPlan>>
>
export type SetInitialPlanMutationBody = SetInitialPlanPayload
export type SetInitialPlanMutationError = AxiosError<unknown>

/**
 * @summary Set Initial Plan
 */
export const useSetInitialPlan = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setInitialPlan>>,
    TError,
    { data: SetInitialPlanPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof setInitialPlan>>,
  TError,
  { data: SetInitialPlanPayload },
  TContext
> => {
  const mutationOptions = getSetInitialPlanMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Set Plan
 */
export const setPlan = (
  setPlanPayload: SetPlanPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<SetPlan200>> => {
  return axios.post(`/set-plan/`, setPlanPayload, options)
}

export const getSetPlanMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setPlan>>,
    TError,
    { data: SetPlanPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof setPlan>>,
  TError,
  { data: SetPlanPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setPlan>>,
    { data: SetPlanPayload }
  > = (props) => {
    const { data } = props ?? {}

    return setPlan(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetPlanMutationResult = NonNullable<
  Awaited<ReturnType<typeof setPlan>>
>
export type SetPlanMutationBody = SetPlanPayload
export type SetPlanMutationError = AxiosError<unknown>

/**
 * @summary Set Plan
 */
export const useSetPlan = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setPlan>>,
    TError,
    { data: SetPlanPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof setPlan>>,
  TError,
  { data: SetPlanPayload },
  TContext
> => {
  const mutationOptions = getSetPlanMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Configure Zendesk
 */
export const configureZendesk = (
  zendeskConfiguration: ZendeskConfiguration,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ZendeskConfiguration>> => {
  return axios.post(
    `/integrations/zendesk/configure/`,
    zendeskConfiguration,
    options
  )
}

export const getConfigureZendeskMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof configureZendesk>>,
    TError,
    { data: ZendeskConfiguration },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof configureZendesk>>,
  TError,
  { data: ZendeskConfiguration },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof configureZendesk>>,
    { data: ZendeskConfiguration }
  > = (props) => {
    const { data } = props ?? {}

    return configureZendesk(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfigureZendeskMutationResult = NonNullable<
  Awaited<ReturnType<typeof configureZendesk>>
>
export type ConfigureZendeskMutationBody = ZendeskConfiguration
export type ConfigureZendeskMutationError = AxiosError<unknown>

/**
 * @summary Configure Zendesk
 */
export const useConfigureZendesk = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof configureZendesk>>,
    TError,
    { data: ZendeskConfiguration },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof configureZendesk>>,
  TError,
  { data: ZendeskConfiguration },
  TContext
> => {
  const mutationOptions = getConfigureZendeskMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Zendesk Info
 */
export const zendeskInfo = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ZendeskInfo>> => {
  return axios.get(`/integrations/zendesk/`, options)
}

export const getZendeskInfoQueryKey = () => {
  return [`/integrations/zendesk/`] as const
}

export const getZendeskInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof zendeskInfo>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof zendeskInfo>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getZendeskInfoQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof zendeskInfo>>> = ({
    signal,
  }) => zendeskInfo({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof zendeskInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ZendeskInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof zendeskInfo>>
>
export type ZendeskInfoQueryError = AxiosError<unknown>

/**
 * @summary Zendesk Info
 */
export const useZendeskInfo = <
  TData = Awaited<ReturnType<typeof zendeskInfo>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof zendeskInfo>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getZendeskInfoQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Jira Info
 */
export const jiraInfo = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<JiraInfo>> => {
  return axios.get(`/integrations/jira/`, options)
}

export const getJiraInfoQueryKey = () => {
  return [`/integrations/jira/`] as const
}

export const getJiraInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof jiraInfo>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof jiraInfo>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getJiraInfoQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraInfo>>> = ({
    signal,
  }) => jiraInfo({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof jiraInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type JiraInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof jiraInfo>>
>
export type JiraInfoQueryError = AxiosError<unknown>

/**
 * @summary Jira Info
 */
export const useJiraInfo = <
  TData = Awaited<ReturnType<typeof jiraInfo>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof jiraInfo>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getJiraInfoQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Jira Api Info
 */
export const jiraApiInfo = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<JiraAPIConfigurationResponse>> => {
  return axios.get(`/integrations/jira-api/`, options)
}

export const getJiraApiInfoQueryKey = () => {
  return [`/integrations/jira-api/`] as const
}

export const getJiraApiInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof jiraApiInfo>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof jiraApiInfo>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getJiraApiInfoQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraApiInfo>>> = ({
    signal,
  }) => jiraApiInfo({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof jiraApiInfo>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type JiraApiInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof jiraApiInfo>>
>
export type JiraApiInfoQueryError = AxiosError<unknown>

/**
 * @summary Jira Api Info
 */
export const useJiraApiInfo = <
  TData = Awaited<ReturnType<typeof jiraApiInfo>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof jiraApiInfo>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getJiraApiInfoQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Configure Jira Api
 */
export const configureJiraApi = (
  jiraAPIConfiguration: JiraAPIConfiguration,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<JiraAPIConfiguration>> => {
  return axios.post(
    `/integrations/jira-api/configure/`,
    jiraAPIConfiguration,
    options
  )
}

export const getConfigureJiraApiMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof configureJiraApi>>,
    TError,
    { data: JiraAPIConfiguration },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof configureJiraApi>>,
  TError,
  { data: JiraAPIConfiguration },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof configureJiraApi>>,
    { data: JiraAPIConfiguration }
  > = (props) => {
    const { data } = props ?? {}

    return configureJiraApi(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfigureJiraApiMutationResult = NonNullable<
  Awaited<ReturnType<typeof configureJiraApi>>
>
export type ConfigureJiraApiMutationBody = JiraAPIConfiguration
export type ConfigureJiraApiMutationError = AxiosError<unknown>

/**
 * @summary Configure Jira Api
 */
export const useConfigureJiraApi = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof configureJiraApi>>,
    TError,
    { data: JiraAPIConfiguration },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof configureJiraApi>>,
  TError,
  { data: JiraAPIConfiguration },
  TContext
> => {
  const mutationOptions = getConfigureJiraApiMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Update Jira Project
 */
export const updateJiraProject = (
  projectStatus: ProjectStatus,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ProjectStatus>> => {
  return axios.post(
    `/integrations/jira/configure/change-project-enabled/`,
    projectStatus,
    options
  )
}

export const getUpdateJiraProjectMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateJiraProject>>,
    TError,
    { data: ProjectStatus },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateJiraProject>>,
  TError,
  { data: ProjectStatus },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateJiraProject>>,
    { data: ProjectStatus }
  > = (props) => {
    const { data } = props ?? {}

    return updateJiraProject(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateJiraProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateJiraProject>>
>
export type UpdateJiraProjectMutationBody = ProjectStatus
export type UpdateJiraProjectMutationError = AxiosError<unknown>

/**
 * @summary Update Jira Project
 */
export const useUpdateJiraProject = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateJiraProject>>,
    TError,
    { data: ProjectStatus },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof updateJiraProject>>,
  TError,
  { data: ProjectStatus },
  TContext
> => {
  const mutationOptions = getUpdateJiraProjectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Zendesk Field Detect
 */
export const zendeskFieldDetection = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ZendeskField>> => {
  return axios.post(
    `/integrations/zendesk/configure/field-detect/`,
    undefined,
    options
  )
}

export const getZendeskFieldDetectionMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof zendeskFieldDetection>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof zendeskFieldDetection>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof zendeskFieldDetection>>,
    void
  > = () => {
    return zendeskFieldDetection(axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ZendeskFieldDetectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof zendeskFieldDetection>>
>

export type ZendeskFieldDetectionMutationError = AxiosError<unknown>

/**
 * @summary Zendesk Field Detect
 */
export const useZendeskFieldDetection = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof zendeskFieldDetection>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof zendeskFieldDetection>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getZendeskFieldDetectionMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Integrations
 */
export const integrations = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<SupportedIntegrations>> => {
  return axios.get(`/integrations/`, options)
}

export const getIntegrationsQueryKey = () => {
  return [`/integrations/`] as const
}

export const getIntegrationsQueryOptions = <
  TData = Awaited<ReturnType<typeof integrations>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof integrations>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getIntegrationsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof integrations>>> = ({
    signal,
  }) => integrations({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof integrations>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type IntegrationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof integrations>>
>
export type IntegrationsQueryError = AxiosError<unknown>

/**
 * @summary Integrations
 */
export const useIntegrations = <
  TData = Awaited<ReturnType<typeof integrations>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof integrations>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getIntegrationsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Analyzed Issues
 */
export const analyzedIssues = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<AnalyzedIssue[]>> => {
  return axios.get(`/issues/analyzed/`, options)
}

export const getAnalyzedIssuesQueryKey = () => {
  return [`/issues/analyzed/`] as const
}

export const getAnalyzedIssuesQueryOptions = <
  TData = Awaited<ReturnType<typeof analyzedIssues>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof analyzedIssues>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAnalyzedIssuesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof analyzedIssues>>> = ({
    signal,
  }) => analyzedIssues({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof analyzedIssues>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type AnalyzedIssuesQueryResult = NonNullable<
  Awaited<ReturnType<typeof analyzedIssues>>
>
export type AnalyzedIssuesQueryError = AxiosError<unknown>

/**
 * @summary Analyzed Issues
 */
export const useAnalyzedIssues = <
  TData = Awaited<ReturnType<typeof analyzedIssues>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof analyzedIssues>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getAnalyzedIssuesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Metrics Cycle Time
 */
export const metricsCycleTime = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<MetricsCycleTime>> => {
  return axios.get(`/metrics/cycle-time/`, options)
}

export const getMetricsCycleTimeQueryKey = () => {
  return [`/metrics/cycle-time/`] as const
}

export const getMetricsCycleTimeQueryOptions = <
  TData = Awaited<ReturnType<typeof metricsCycleTime>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof metricsCycleTime>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMetricsCycleTimeQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metricsCycleTime>>
  > = ({ signal }) => metricsCycleTime({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof metricsCycleTime>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type MetricsCycleTimeQueryResult = NonNullable<
  Awaited<ReturnType<typeof metricsCycleTime>>
>
export type MetricsCycleTimeQueryError = AxiosError<unknown>

/**
 * @summary Metrics Cycle Time
 */
export const useMetricsCycleTime = <
  TData = Awaited<ReturnType<typeof metricsCycleTime>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof metricsCycleTime>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getMetricsCycleTimeQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Analysis Report Status
 */
export const reportAnalysisStatus = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<AnalysisReportStatus>> => {
  return axios.get(`/report/analysis-status/`, options)
}

export const getReportAnalysisStatusQueryKey = () => {
  return [`/report/analysis-status/`] as const
}

export const getReportAnalysisStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof reportAnalysisStatus>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof reportAnalysisStatus>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReportAnalysisStatusQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportAnalysisStatus>>
  > = ({ signal }) => reportAnalysisStatus({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportAnalysisStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ReportAnalysisStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportAnalysisStatus>>
>
export type ReportAnalysisStatusQueryError = AxiosError<unknown>

/**
 * @summary Analysis Report Status
 */
export const useReportAnalysisStatus = <
  TData = Awaited<ReturnType<typeof reportAnalysisStatus>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof reportAnalysisStatus>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getReportAnalysisStatusQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Analysis Report
 */
export const reportAnalysis = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<AnalysisReport>> => {
  return axios.get(`/report/analysis/`, options)
}

export const getReportAnalysisQueryKey = () => {
  return [`/report/analysis/`] as const
}

export const getReportAnalysisQueryOptions = <
  TData = Awaited<ReturnType<typeof reportAnalysis>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof reportAnalysis>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReportAnalysisQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof reportAnalysis>>> = ({
    signal,
  }) => reportAnalysis({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportAnalysis>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ReportAnalysisQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportAnalysis>>
>
export type ReportAnalysisQueryError = AxiosError<unknown>

/**
 * @summary Analysis Report
 */
export const useReportAnalysis = <
  TData = Awaited<ReturnType<typeof reportAnalysis>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof reportAnalysis>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getReportAnalysisQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Trigger Report Analysis
 */
export const triggerAnalysis = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<AnalysisReportStatus>> => {
  return axios.post(`/report/trigger-analysis/`, undefined, options)
}

export const getTriggerAnalysisMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof triggerAnalysis>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof triggerAnalysis>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof triggerAnalysis>>,
    void
  > = () => {
    return triggerAnalysis(axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TriggerAnalysisMutationResult = NonNullable<
  Awaited<ReturnType<typeof triggerAnalysis>>
>

export type TriggerAnalysisMutationError = AxiosError<unknown>

/**
 * @summary Trigger Report Analysis
 */
export const useTriggerAnalysis = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof triggerAnalysis>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof triggerAnalysis>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getTriggerAnalysisMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Set Account Type
 */
export const setAccountType = (
  accountTypePayload: AccountTypePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<OnboardingStatus>> => {
  return axios.post(`/set-account-type/`, accountTypePayload, options)
}

export const getSetAccountTypeMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setAccountType>>,
    TError,
    { data: AccountTypePayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof setAccountType>>,
  TError,
  { data: AccountTypePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setAccountType>>,
    { data: AccountTypePayload }
  > = (props) => {
    const { data } = props ?? {}

    return setAccountType(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SetAccountTypeMutationResult = NonNullable<
  Awaited<ReturnType<typeof setAccountType>>
>
export type SetAccountTypeMutationBody = AccountTypePayload
export type SetAccountTypeMutationError = AxiosError<unknown>

/**
 * @summary Set Account Type
 */
export const useSetAccountType = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setAccountType>>,
    TError,
    { data: AccountTypePayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof setAccountType>>,
  TError,
  { data: AccountTypePayload },
  TContext
> => {
  const mutationOptions = getSetAccountTypeMutationOptions(options)

  return useMutation(mutationOptions)
}
