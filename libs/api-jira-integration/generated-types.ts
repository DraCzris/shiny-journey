/**
 * Generated by orval v6.29.1 üç∫
 * Do not edit manually.
 * Jira API
 * API used by Jira plugin and its installation process
 * OpenAPI spec version: 1
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import axios from 'axios'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
export type GetFieldsParams = {
  ids: string[]
}

export type AddAccountToVoucherPayload = {
  auth0_jwt: string
  voucher_code: string
}

export type AddAccountToVoucherResponse = {
  callback_url: string
}

export type InstalledResponse = {
  status: string
}

export type EnsureIssuePayloadIssueId = string | null

export type EnsureIssuePayload = {
  issue_id?: EnsureIssuePayloadIssueId
}

export type ZendeskTicketType =
  (typeof ZendeskTicketType)[keyof typeof ZendeskTicketType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ZendeskTicketType = {
  zendesk: 'zendesk',
} as const

export type ZendeskTicket = {
  title: string
  type?: ZendeskTicketType
  url: string
}

export type JiraIssueType = (typeof JiraIssueType)[keyof typeof JiraIssueType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JiraIssueType = {
  jira: 'jira',
} as const

export type JiraIssue = {
  key: string
  type?: JiraIssueType
}

export type IssueExtra = ZendeskTicket | JiraIssue

export type Issue = {
  extra: IssueExtra
  fields: Field[]
  id: string
  tenant?: IssueTenant
}

export type EnsureIssueResponse = {
  issue: Issue
  linked_zendesk_issues: Issue[]
}

export type TenantName = string | null

export type TenantAccount = ShowcaseAccount | StandardAccount

export type Tenant = {
  account: TenantAccount
  id: string
  name?: TenantName
}

export type IssueTenant = Tenant | null

export type Subscription = {
  active_from: string
  data: Plan
  schedule?: SubscriptionSchedule
}

export type StandardAccountType =
  (typeof StandardAccountType)[keyof typeof StandardAccountType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StandardAccountType = {
  standard: 'standard',
} as const

export type StandardAccountSubscription = Subscription | null

export type StandardAccountQuota = Quota | null

export type StandardAccount = {
  is_linked: boolean
  quota?: StandardAccountQuota
  subscription?: StandardAccountSubscription
  type?: StandardAccountType
}

export type ShowcaseAccountType =
  (typeof ShowcaseAccountType)[keyof typeof ShowcaseAccountType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ShowcaseAccountType = {
  showcase: 'showcase',
} as const

export type ShowcaseAccount = {
  type?: ShowcaseAccountType
}

export type ScheduleScheduledTo = string | null

export type Schedule = {
  new_plan: Plan
  scheduled_to?: ScheduleScheduledTo
}

export type SubscriptionSchedule = Schedule | null

export type Quota = {
  limit: number
  used: number
}

export type PlanPriceVat = number | string

export type PlanPrice = number | string

export type Plan = {
  billing_period: string
  id: string
  is_default: boolean
  price: PlanPrice
  price_vat: PlanPriceVat
  title: string
}

export type InstallationStatus = {
  is_linked: boolean
}

export type FinalizeLinkPayload = {
  voucher_code: string
}

export type Voucher = {
  base_url: string
  code: string
}

export type FeedbackPayload = {
  score: number
  score_reason: string
}

export type ProcessingType =
  (typeof ProcessingType)[keyof typeof ProcessingType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProcessingType = {
  processing: 'processing',
} as const

export type ProcessingError = string | null

export type ProcessingContent = string | null

export type Processing = {
  content?: ProcessingContent
  error?: ProcessingError
  initiated_at: string
  initiated_by: string
  type?: ProcessingType
}

export type OkType = (typeof OkType)[keyof typeof OkType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OkType = {
  ok: 'ok',
} as const

export type Ok = {
  content: string
  type?: OkType
  updated_at: string
  updated_by: string
}

export type Field = {
  created_at: string
  id: string
  status: FieldStatus
  system_name: string
  title: string
}

export type ErrorType = (typeof ErrorType)[keyof typeof ErrorType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorType = {
  error: 'error',
} as const

export type ErrorContent = string | null

export type Error = {
  content?: ErrorContent
  failed_at: string
  message: string
  type?: ErrorType
}

export type FieldStatus = Ok | Error | Processing

export type GetFieldsFilter = {
  ids: string[]
}

/**
 * @summary Fields
 */
export const getFields = (
  params: GetFieldsParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Field[]>> => {
  return axios.get(`/api/jira/fields/`, {
    ...options,
    params: { ...params, ...options?.params },
  })
}

export const getGetFieldsQueryKey = (params: GetFieldsParams) => {
  return [`/api/jira/fields/`, ...(params ? [params] : [])] as const
}

export const getGetFieldsQueryOptions = <
  TData = Awaited<ReturnType<typeof getFields>>,
  TError = AxiosError<unknown>,
>(
  params: GetFieldsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFields>>, TError, TData>
    >
    axios?: AxiosRequestConfig
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFieldsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFields>>> = ({
    signal,
  }) => getFields(params, { signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFields>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetFieldsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFields>>
>
export type GetFieldsQueryError = AxiosError<unknown>

/**
 * @summary Fields
 */
export const useGetFields = <
  TData = Awaited<ReturnType<typeof getFields>>,
  TError = AxiosError<unknown>,
>(
  params: GetFieldsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFields>>, TError, TData>
    >
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetFieldsQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Submit Feedback
 */
export const submitFeedback = (
  feedbackPayload: FeedbackPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<FeedbackPayload>> => {
  return axios.post(`/api/jira/submit-feedback/`, feedbackPayload, options)
}

export const getSubmitFeedbackMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof submitFeedback>>,
    TError,
    { data: FeedbackPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof submitFeedback>>,
  TError,
  { data: FeedbackPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof submitFeedback>>,
    { data: FeedbackPayload }
  > = (props) => {
    const { data } = props ?? {}

    return submitFeedback(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SubmitFeedbackMutationResult = NonNullable<
  Awaited<ReturnType<typeof submitFeedback>>
>
export type SubmitFeedbackMutationBody = FeedbackPayload
export type SubmitFeedbackMutationError = AxiosError<unknown>

/**
 * @summary Submit Feedback
 */
export const useSubmitFeedback = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof submitFeedback>>,
    TError,
    { data: FeedbackPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof submitFeedback>>,
  TError,
  { data: FeedbackPayload },
  TContext
> => {
  const mutationOptions = getSubmitFeedbackMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Create Voucher
 */
export const createVoucher = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Voucher>> => {
  return axios.post(`/api/jira/create-voucher/`, undefined, options)
}

export const getCreateVoucherMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVoucher>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof createVoucher>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createVoucher>>,
    void
  > = () => {
    return createVoucher(axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateVoucherMutationResult = NonNullable<
  Awaited<ReturnType<typeof createVoucher>>
>

export type CreateVoucherMutationError = AxiosError<unknown>

/**
 * @summary Create Voucher
 */
export const useCreateVoucher = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVoucher>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof createVoucher>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getCreateVoucherMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Finalize Link
 */
export const finalizeLink = (
  finalizeLinkPayload: FinalizeLinkPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/api/jira/finalize-link/`, finalizeLinkPayload, options)
}

export const getFinalizeLinkMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof finalizeLink>>,
    TError,
    { data: FinalizeLinkPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof finalizeLink>>,
  TError,
  { data: FinalizeLinkPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof finalizeLink>>,
    { data: FinalizeLinkPayload }
  > = (props) => {
    const { data } = props ?? {}

    return finalizeLink(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type FinalizeLinkMutationResult = NonNullable<
  Awaited<ReturnType<typeof finalizeLink>>
>
export type FinalizeLinkMutationBody = FinalizeLinkPayload
export type FinalizeLinkMutationError = AxiosError<unknown>

/**
 * @summary Finalize Link
 */
export const useFinalizeLink = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof finalizeLink>>,
    TError,
    { data: FinalizeLinkPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof finalizeLink>>,
  TError,
  { data: FinalizeLinkPayload },
  TContext
> => {
  const mutationOptions = getFinalizeLinkMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Installation Status
 */
export const installationStatus = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<InstallationStatus>> => {
  return axios.get(`/api/jira/installation-status/`, options)
}

export const getInstallationStatusQueryKey = () => {
  return [`/api/jira/installation-status/`] as const
}

export const getInstallationStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof installationStatus>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof installationStatus>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getInstallationStatusQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof installationStatus>>
  > = ({ signal }) => installationStatus({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof installationStatus>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type InstallationStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof installationStatus>>
>
export type InstallationStatusQueryError = AxiosError<unknown>

/**
 * @summary Installation Status
 */
export const useInstallationStatus = <
  TData = Awaited<ReturnType<typeof installationStatus>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof installationStatus>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getInstallationStatusQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get Tenant
 */
export const getTenant = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Tenant>> => {
  return axios.get(`/api/jira/get-tenant/`, options)
}

export const getGetTenantQueryKey = () => {
  return [`/api/jira/get-tenant/`] as const
}

export const getGetTenantQueryOptions = <
  TData = Awaited<ReturnType<typeof getTenant>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTenantQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenant>>> = ({
    signal,
  }) => getTenant({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTenant>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type GetTenantQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTenant>>
>
export type GetTenantQueryError = AxiosError<unknown>

/**
 * @summary Get Tenant
 */
export const useGetTenant = <
  TData = Awaited<ReturnType<typeof getTenant>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetTenantQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Ensure Issue
 */
export const ensureIssue = (
  ensureIssuePayload: EnsureIssuePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EnsureIssueResponse>> => {
  return axios.post(`/api/jira/ensure-issue/`, ensureIssuePayload, options)
}

export const getEnsureIssueMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ensureIssue>>,
    TError,
    { data: EnsureIssuePayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof ensureIssue>>,
  TError,
  { data: EnsureIssuePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ensureIssue>>,
    { data: EnsureIssuePayload }
  > = (props) => {
    const { data } = props ?? {}

    return ensureIssue(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EnsureIssueMutationResult = NonNullable<
  Awaited<ReturnType<typeof ensureIssue>>
>
export type EnsureIssueMutationBody = EnsureIssuePayload
export type EnsureIssueMutationError = AxiosError<unknown>

/**
 * @summary Ensure Issue
 */
export const useEnsureIssue = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof ensureIssue>>,
    TError,
    { data: EnsureIssuePayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof ensureIssue>>,
  TError,
  { data: EnsureIssuePayload },
  TContext
> => {
  const mutationOptions = getEnsureIssueMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Installation Finished
 */
export const installationFinished = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<InstalledResponse>> => {
  return axios.post(`/installation/jira/finished/`, undefined, options)
}

export const getInstallationFinishedMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof installationFinished>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof installationFinished>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof installationFinished>>,
    void
  > = () => {
    return installationFinished(axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type InstallationFinishedMutationResult = NonNullable<
  Awaited<ReturnType<typeof installationFinished>>
>

export type InstallationFinishedMutationError = AxiosError<unknown>

/**
 * @summary Installation Finished
 */
export const useInstallationFinished = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof installationFinished>>,
    TError,
    void,
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof installationFinished>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getInstallationFinishedMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Connect View
 */
export const installationConnect = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/installation/jira/connect/`, options)
}

export const getInstallationConnectQueryKey = () => {
  return [`/installation/jira/connect/`] as const
}

export const getInstallationConnectQueryOptions = <
  TData = Awaited<ReturnType<typeof installationConnect>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof installationConnect>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getInstallationConnectQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof installationConnect>>
  > = ({ signal }) => installationConnect({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof installationConnect>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type InstallationConnectQueryResult = NonNullable<
  Awaited<ReturnType<typeof installationConnect>>
>
export type InstallationConnectQueryError = AxiosError<unknown>

/**
 * @summary Connect View
 */
export const useInstallationConnect = <
  TData = Awaited<ReturnType<typeof installationConnect>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof installationConnect>>,
      TError,
      TData
    >
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getInstallationConnectQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Add Account To Voucher
 */
export const addAccountToVoucher = (
  addAccountToVoucherPayload: AddAccountToVoucherPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<AddAccountToVoucherResponse>> => {
  return axios.post(
    `/internal/jira/add-account-to-voucher/`,
    addAccountToVoucherPayload,
    options
  )
}

export const getAddAccountToVoucherMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addAccountToVoucher>>,
    TError,
    { data: AddAccountToVoucherPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationOptions<
  Awaited<ReturnType<typeof addAccountToVoucher>>,
  TError,
  { data: AddAccountToVoucherPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addAccountToVoucher>>,
    { data: AddAccountToVoucherPayload }
  > = (props) => {
    const { data } = props ?? {}

    return addAccountToVoucher(data, axiosOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddAccountToVoucherMutationResult = NonNullable<
  Awaited<ReturnType<typeof addAccountToVoucher>>
>
export type AddAccountToVoucherMutationBody = AddAccountToVoucherPayload
export type AddAccountToVoucherMutationError = AxiosError<unknown>

/**
 * @summary Add Account To Voucher
 */
export const useAddAccountToVoucher = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addAccountToVoucher>>,
    TError,
    { data: AddAccountToVoucherPayload },
    TContext
  >
  axios?: AxiosRequestConfig
}): UseMutationResult<
  Awaited<ReturnType<typeof addAccountToVoucher>>,
  TError,
  { data: AddAccountToVoucherPayload },
  TContext
> => {
  const mutationOptions = getAddAccountToVoucherMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Index
 */
export const index = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/app/jira/`, options)
}

export const getIndexQueryKey = () => {
  return [`/app/jira/`] as const
}

export const getIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof index>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof index>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getIndexQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof index>>> = ({
    signal,
  }) => index({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof index>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type IndexQueryResult = NonNullable<Awaited<ReturnType<typeof index>>>
export type IndexQueryError = AxiosError<unknown>

/**
 * @summary Index
 */
export const useIndex = <
  TData = Awaited<ReturnType<typeof index>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof index>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getIndexQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Survey
 */
export const survey = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/app/jira/survey/`, options)
}

export const getSurveyQueryKey = () => {
  return [`/app/jira/survey/`] as const
}

export const getSurveyQueryOptions = <
  TData = Awaited<ReturnType<typeof survey>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof survey>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSurveyQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof survey>>> = ({
    signal,
  }) => survey({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof survey>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type SurveyQueryResult = NonNullable<Awaited<ReturnType<typeof survey>>>
export type SurveyQueryError = AxiosError<unknown>

/**
 * @summary Survey
 */
export const useSurvey = <
  TData = Awaited<ReturnType<typeof survey>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof survey>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getSurveyQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Link
 */
export const link = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/app/jira/link/`, options)
}

export const getLinkQueryKey = () => {
  return [`/app/jira/link/`] as const
}

export const getLinkQueryOptions = <
  TData = Awaited<ReturnType<typeof link>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof link>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLinkQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof link>>> = ({
    signal,
  }) => link({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof link>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type LinkQueryResult = NonNullable<Awaited<ReturnType<typeof link>>>
export type LinkQueryError = AxiosError<unknown>

/**
 * @summary Link
 */
export const useLink = <
  TData = Awaited<ReturnType<typeof link>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof link>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getLinkQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Link Finalized
 */
export const linkFinalized = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/app/jira/link/finalize/`, options)
}

export const getLinkFinalizedQueryKey = () => {
  return [`/app/jira/link/finalize/`] as const
}

export const getLinkFinalizedQueryOptions = <
  TData = Awaited<ReturnType<typeof linkFinalized>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof linkFinalized>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLinkFinalizedQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof linkFinalized>>> = ({
    signal,
  }) => linkFinalized({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof linkFinalized>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type LinkFinalizedQueryResult = NonNullable<
  Awaited<ReturnType<typeof linkFinalized>>
>
export type LinkFinalizedQueryError = AxiosError<unknown>

/**
 * @summary Link Finalized
 */
export const useLinkFinalized = <
  TData = Awaited<ReturnType<typeof linkFinalized>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof linkFinalized>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getLinkFinalizedQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}
